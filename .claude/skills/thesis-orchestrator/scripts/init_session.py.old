#!/usr/bin/env python3
"""Session initialization module for doctoral research workflow.

This module handles the creation and management of research sessions,
including directory structure creation and session state management.
"""

import json
import re
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import Any

# Import new folder structure creator
from create_folder_structure import create_research_folder_structure

# Constants
VERSION = "2.0.0"
TOTAL_STEPS = 150
VALID_MODES = {"topic", "question", "review", "learning"}
VALID_RESEARCH_TYPES = {"quantitative", "qualitative", "mixed", None}
VALID_CITATION_STYLES = {"apa7", "chicago", "mla9", "harvard"}
VALID_LANGUAGES = {"korean", "english", "bilingual"}
VALID_THESIS_FORMATS = {"traditional_5chapter", "three_paper", "monograph"}


def get_current_timestamp() -> str:
    """Return current UTC timestamp in ISO format."""
    return datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")


def sanitize_filename(title: str) -> str:
    """Sanitize a title for use as a filename.

    Args:
        title: The original title string

    Returns:
        A sanitized string safe for use in filenames
    """
    # Replace problematic characters with underscores
    sanitized = re.sub(r'[/:*?"<>|\\]', '_', title)
    # Replace multiple underscores with single
    sanitized = re.sub(r'_+', '_', sanitized)
    # Remove leading/trailing underscores
    sanitized = sanitized.strip('_')
    # Limit length
    return sanitized[:50] if len(sanitized) > 50 else sanitized


def create_session(
    topic: str,
    mode: str,
    output_dir: Path,
    research_type: str | None = None,
    discipline: str | None = None,
) -> dict[str, Any]:
    """Create a new session structure.

    Args:
        topic: Research topic or question
        mode: Input mode (topic, question, review, learning)
        output_dir: Base output directory
        research_type: Research type (quantitative, qualitative, mixed)
        discipline: Academic discipline

    Returns:
        A dictionary containing the session structure
    """
    timestamp = get_current_timestamp()

    return {
        "version": VERSION,
        "created_at": timestamp,
        "updated_at": timestamp,
        "research": {
            "topic": topic,
            "mode": mode,
            "type": research_type,
            "discipline": discipline,
            "research_questions": [],
            "hypotheses": [],
        },
        "workflow": {
            "current_phase": "phase0",
            "current_step": 1,
            "total_steps": TOTAL_STEPS,
            "last_checkpoint": None,
            "last_agent": None,
        },
        "options": {
            "literature_depth": "comprehensive",
            "theoretical_framework": "existing",
            "citation_style": "apa7",
            "language": "korean",
            "thesis_format": "traditional_5chapter",
        },
        "quality": {
            "srcs_scores": [],
            "gra_validations": [],
            "plagiarism_checks": [],
        },
        "context_snapshots": [],
    }


def save_session(session: dict[str, Any], path: Path) -> None:
    """Save session to a JSON file.

    Args:
        session: Session dictionary to save
        path: Path to save the session file
    """
    path.parent.mkdir(parents=True, exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        json.dump(session, f, ensure_ascii=False, indent=2)


def load_session(path: Path) -> dict[str, Any]:
    """Load session from a JSON file.

    Args:
        path: Path to the session file

    Returns:
        Session dictionary

    Raises:
        FileNotFoundError: If session file doesn't exist
    """
    with open(path, encoding="utf-8") as f:
        return json.load(f)


def create_output_structure(base_dir: Path, research_title: str) -> Path:
    """Create the output directory structure for a research project.

    Uses the new systematic folder structure (v2.0) for better documentation.

    Args:
        base_dir: Base directory for thesis output
        research_title: Title of the research project

    Returns:
        Path to the created output directory
    """
    today = datetime.now().strftime("%Y-%m-%d")
    sanitized_title = sanitize_filename(research_title)

    # Use the new folder structure creator
    output_dir = create_research_folder_structure(
        base_dir=base_dir,
        topic=sanitized_title,
        date_str=today
    )

    return output_dir


def validate_session(session: dict[str, Any]) -> tuple[bool, list[str]]:
    """Validate a session structure.

    Args:
        session: Session dictionary to validate

    Returns:
        Tuple of (is_valid, list of error messages)
    """
    errors = []

    # Check required top-level fields
    required_fields = ["version", "research", "workflow", "options", "quality"]
    for field in required_fields:
        if field not in session:
            errors.append(f"Missing required field: {field}")

    if errors:
        return False, errors

    # Validate version (accept both 1.x and 2.x for backwards compatibility)
    valid_versions = {"1.0.0", "2.0.0"}
    if session["version"] not in valid_versions:
        errors.append(f"Invalid version: {session['version']}, expected one of {valid_versions}")

    # Validate research section
    research = session.get("research", {})
    if research.get("mode") not in VALID_MODES:
        errors.append(f"Invalid mode: {research.get('mode')}. Must be one of {VALID_MODES}")

    if research.get("type") not in VALID_RESEARCH_TYPES:
        errors.append(f"Invalid research type: {research.get('type')}")

    # Validate workflow section
    workflow = session.get("workflow", {})
    if not isinstance(workflow.get("current_step"), int) or workflow.get("current_step", 0) < 1:
        errors.append("current_step must be a positive integer")

    if not isinstance(workflow.get("total_steps"), int) or workflow.get("total_steps", 0) < 1:
        errors.append("total_steps must be a positive integer")

    # Validate options section
    options = session.get("options", {})
    if options.get("citation_style") not in VALID_CITATION_STYLES:
        errors.append(f"Invalid citation style: {options.get('citation_style')}")

    if options.get("language") not in VALID_LANGUAGES:
        errors.append(f"Invalid language: {options.get('language')}")

    return len(errors) == 0, errors


def create_checklist(output_dir: Path) -> Path:
    """Create the 150-step todo checklist.

    Args:
        output_dir: Output directory for the checklist

    Returns:
        Path to the created checklist file
    """
    checklist_path = output_dir / "todo-checklist.md"

    checklist_content = """# 박사논문 연구 워크플로우 체크리스트 (150단계)

## Phase 0: 초기화 (Steps 1-8)

- [ ] 1. 세션 초기화
- [ ] 2. 연구유형 선택
- [ ] 3. 학문분야 선택
- [ ] 4. 사용자 리소스 확인
- [ ] 5. 입력 모드 확인
- [ ] 6. 연구 주제/질문 입력
- [ ] 7. 초기 설정 완료
- [ ] 8. HITL-0 체크포인트

## Phase 0-A: 주제 탐색 (Steps 9-14) [Mode A Only]

- [ ] 9. 주제 학술적 맥락 분석
- [ ] 10. 연구 트렌드 파악
- [ ] 11. 연구질문 후보 도출
- [ ] 12. 학술적 기여 가능성 평가
- [ ] 13. 연구질문 후보 정리
- [ ] 14. HITL-1 체크포인트 준비

## HITL-1: 연구질문 확정 (Steps 15-18)

- [ ] 15. 연구질문 후보 제시
- [ ] 16. 사용자 선택 대기
- [ ] 17. 문헌검토 깊이 설정
- [ ] 18. 이론적 프레임워크 옵션 설정

## Phase 1 Wave 1: 기초 문헌 탐색 (Steps 19-34)

- [ ] 19. @literature-searcher 시작
- [ ] 20. 검색 전략 수립
- [ ] 21. 데이터베이스 검색
- [ ] 22. 검색 결과 스크리닝
- [ ] 23. @literature-searcher 완료
- [ ] 24. @seminal-works-analyst 시작
- [ ] 25. 핵심 문헌 식별
- [ ] 26. 인용 네트워크 분석
- [ ] 27. @seminal-works-analyst 완료
- [ ] 28. @trend-analyst 시작
- [ ] 29. 시계열 동향 분석
- [ ] 30. 연구 핫스팟 파악
- [ ] 31. @trend-analyst 완료
- [ ] 32. @methodology-scanner 시작
- [ ] 33. 방법론 유형 분류
- [ ] 34. Cross-Validation Gate 1

## Phase 1 Wave 2: 심층 분석 (Steps 35-50)

- [ ] 35. @theoretical-framework-analyst 시작
- [ ] 36. 이론 식별 및 검토
- [ ] 37. 이론적 렌즈 제안
- [ ] 38. @theoretical-framework-analyst 완료
- [ ] 39. @empirical-evidence-analyst 시작
- [ ] 40. 실증연구 결과 정리
- [ ] 41. 효과 크기 분석
- [ ] 42. @empirical-evidence-analyst 완료
- [ ] 43. @gap-identifier 시작
- [ ] 44. 연구 갭 식별
- [ ] 45. 갭 중요성 평가
- [ ] 46. @gap-identifier 완료
- [ ] 47. @variable-relationship-analyst 시작
- [ ] 48. 변수 관계 분석
- [ ] 49. @variable-relationship-analyst 완료
- [ ] 50. Cross-Validation Gate 2

## Phase 1 Wave 3: 비판적 분석 (Steps 51-66)

- [ ] 51. @critical-reviewer 시작
- [ ] 52. 논리적 일관성 평가
- [ ] 53. 대안적 해석 탐색
- [ ] 54. @critical-reviewer 완료
- [ ] 55. @methodology-critic 시작
- [ ] 56. 타당도 위협 분석
- [ ] 57. 측정 신뢰도 검토
- [ ] 58. @methodology-critic 완료
- [ ] 59. @limitation-analyst 시작
- [ ] 60. 공통 한계점 정리
- [ ] 61. 극복 가능 한계 식별
- [ ] 62. @limitation-analyst 완료
- [ ] 63. @future-direction-analyst 시작
- [ ] 64. 후속 연구 정리
- [ ] 65. @future-direction-analyst 완료
- [ ] 66. Cross-Validation Gate 3

## Phase 1 Wave 4: 종합 (Steps 67-74)

- [ ] 67. @synthesis-agent 시작
- [ ] 68. 문헌 주제별 종합
- [ ] 69. 문헌검토 초안 작성
- [ ] 70. @synthesis-agent 완료
- [ ] 71. @conceptual-model-builder 시작
- [ ] 72. 연구모델 시각화
- [ ] 73. @conceptual-model-builder 완료
- [ ] 74. Full SRCS Evaluation

## Phase 1 Wave 5: 품질 보증 (Steps 75-82)

- [ ] 75. @plagiarism-checker 시작
- [ ] 76. 원본성 검사
- [ ] 77. @plagiarism-checker 완료
- [ ] 78. @unified-srcs-evaluator 시작
- [ ] 79. 전체 클레임 평가
- [ ] 80. @unified-srcs-evaluator 완료
- [ ] 81. @research-synthesizer 시작
- [ ] 82. Insights File 생성

## HITL-2: 문헌검토 결과 검토 (Steps 83-88)

- [ ] 83. 15개 분석 결과 요약 제시
- [ ] 84. SRCS 품질 보고서 제시
- [ ] 85. 표절 검사 결과 제시
- [ ] 86. 사용자 검토 대기
- [ ] 87. 피드백 반영
- [ ] 88. Context Snapshot 저장

## Phase 2: 연구설계 (Steps 89-108)

- [ ] 89. HITL-3 연구유형 최종 확정
- [ ] 90. 연구유형별 분기
- [ ] 91. 가설/연구질문 정교화
- [ ] 92. 연구모델 개발
- [ ] 93. 표본/참여자 설계
- [ ] 94. 분석 계획 수립
- [ ] 95. [양적] @hypothesis-developer
- [ ] 96. [양적] @research-model-developer
- [ ] 97. [양적] @sampling-designer
- [ ] 98. [양적] @statistical-planner
- [ ] 99. [질적] @paradigm-consultant
- [ ] 100. [질적] @participant-selector
- [ ] 101. [질적] @qualitative-data-designer
- [ ] 102. [질적] @qualitative-analysis-planner
- [ ] 103. [혼합] @mixed-methods-designer
- [ ] 104. [혼합] @integration-strategist
- [ ] 105. 연구설계 문서 통합
- [ ] 106. HITL-4 연구설계 검토
- [ ] 107. 피드백 반영
- [ ] 108. Context Snapshot 저장

## Phase 3: 논문 작성 (Steps 109-132)

- [ ] 109. HITL-5 논문 형식 선택
- [ ] 110. 인용 스타일 설정
- [ ] 111. @thesis-architect 시작
- [ ] 112. 상세 아웃라인 설계
- [ ] 113. @thesis-architect 완료
- [ ] 114. HITL-6 아웃라인 승인
- [ ] 115. @thesis-writer Ch.1 서론
- [ ] 116. Ch.1 검토
- [ ] 117. @thesis-writer Ch.2 문헌검토
- [ ] 118. Ch.2 검토
- [ ] 119. @thesis-writer Ch.3 연구방법
- [ ] 120. Ch.3 검토
- [ ] 121. @thesis-writer Ch.4 연구결과
- [ ] 122. Ch.4 검토
- [ ] 123. @thesis-writer Ch.5 결론
- [ ] 124. Ch.5 검토
- [ ] 125. @thesis-reviewer 품질 검토
- [ ] 126. @plagiarism-checker 최종
- [ ] 127. HITL-7 초안 검토
- [ ] 128. 피드백 반영
- [ ] 129. 최종본 작성
- [ ] 130. 참고문헌 정리
- [ ] 131. 부록 정리
- [ ] 132. Context Snapshot 저장

## Phase 4: 투고 전략 (Steps 133-146)

- [ ] 133. @publication-strategist 시작
- [ ] 134. 적합 학술지 분석
- [ ] 135. 투고 우선순위 추천
- [ ] 136. @publication-strategist 완료
- [ ] 137. @manuscript-formatter 시작
- [ ] 138. 원고 포맷 변환
- [ ] 139. Abstract 작성
- [ ] 140. Keywords 선정
- [ ] 141. Cover Letter 작성
- [ ] 142. @manuscript-formatter 완료
- [ ] 143. 투고 체크리스트 확인
- [ ] 144. HITL-8 최종 검토
- [ ] 145. 최종 승인
- [ ] 146. 워크플로우 완료

## 완료 및 아카이브 (Steps 147-150)

- [ ] 147. 최종 산출물 정리
- [ ] 148. Context Snapshot 최종 저장
- [ ] 149. 워크플로우 로그 아카이브
- [ ] 150. 세션 종료

---

**진행 상태**: Step 1 / 150
**현재 Phase**: Phase 0 - 초기화
**마지막 업데이트**: {timestamp}
""".format(timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S"))

    with open(checklist_path, "w", encoding="utf-8") as f:
        f.write(checklist_content)

    return checklist_path


def initialize_workflow(
    topic: str,
    mode: str,
    base_dir: Path,
    research_type: str | None = None,
    discipline: str | None = None,
) -> Path:
    """Initialize a complete research workflow.

    This is the main entry point for workflow initialization.
    Creates the output directory structure, session file, and checklist.

    Args:
        topic: Research topic or question
        mode: Input mode (topic, question, review, learning)
        base_dir: Base directory for thesis output
        research_type: Research type (quantitative, qualitative, mixed)
        discipline: Academic discipline

    Returns:
        Path to the output directory
    """
    # Create output directory structure
    output_dir = create_output_structure(base_dir, topic)

    # Create session
    session = create_session(
        topic=topic,
        mode=mode,
        output_dir=output_dir,
        research_type=research_type,
        discipline=discipline,
    )

    # Save session to new location (00-session/)
    session_path = output_dir / "00-session" / "session.json"
    save_session(session, session_path)

    # Create checklist in 00-session/
    create_checklist(output_dir / "00-session")

    return output_dir


def main():
    """Main entry point for CLI usage."""
    import argparse

    parser = argparse.ArgumentParser(
        description="Initialize a doctoral research workflow session"
    )
    parser.add_argument("topic", help="Research topic or question")
    parser.add_argument(
        "--mode",
        choices=["topic", "question", "review", "learning"],
        default="topic",
        help="Input mode"
    )
    parser.add_argument(
        "--base-dir",
        type=Path,
        default=Path("thesis-output"),
        help="Base directory for output"
    )
    parser.add_argument(
        "--type",
        choices=["quantitative", "qualitative", "mixed"],
        help="Research type"
    )
    parser.add_argument(
        "--discipline",
        help="Academic discipline"
    )

    args = parser.parse_args()

    output_dir = initialize_workflow(
        topic=args.topic,
        mode=args.mode,
        base_dir=args.base_dir,
        research_type=args.type,
        discipline=args.discipline,
    )

    print(f"Workflow initialized at: {output_dir}")
    print(f"Session file: {output_dir / '00-session' / 'session.json'}")
    print(f"Checklist: {output_dir / '00-session' / 'todo-checklist.md'}")
    print(f"Folder structure version: 2.0.0")


if __name__ == "__main__":
    main()
